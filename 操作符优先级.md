# 操作符优先级

* 21
  * ()
* 20
  * new A()
  * a.b, a['b'], a?.b
  * func(a, b)
* 19  <font color="green"> (**结合性**从右到左)</font>
  * new A
* 18
  * a--
  * a++
* 17  <font color="green"> (**结合性**从右到左)</font>
  * --a
  * ++a
  * -a
  * +a
  * !
  * typeof
  * delete
  * await
  * void
* 16  <font color="green"> (从右到左)</font>
  * a ** b
* 15
  * a * b
  * a / b
  * a % b
* 14
  * a + b
  * a - b
* 12
  * < , >, <=, >=
  * in
  * Instanceof
* 11
  * ==
  * !=
  * ===
  * !==
* 7
  * &&
* 6
  * ||
* 5
  * ??
* 4  <font color="green"> (**结合性**从右到左)</font>
  * ... ? ...  : ....
* 3  <font color="green"> (**结合性**从右到左)</font>
  * = 赋值
  * +=
  * *=
  * -=
* 0
  * ,

## 案例

```js
 var a = {n: 1};
 var b = a;
 a.x = a = {n: 2};
 console.log(a); // ?
 console.log(b); // ?
 console.log(a.x);  // ?

// 先取 a.x，锁定 .x 的引用是 {n: 1}
// 再给 a 赋值
// 这时 a 的引用已经变成 {n: 2}，b 的引用还是 {n: 1}
// 最后给 a.x 赋值，也就是给 b.x 赋值
```

```js
 var a = {n: 1};
 var b = a;
 a = a.x = {n: 2};
 console.log(a); // ?
 console.log(b); // ?
 console.log(a.x);  // ?

// 先取 a.x，锁定 .x 引用是 {n: 1}
// 再给 a.x 赋值
// 这时 a 的引用没变，b 的引用也没
// 最后给 a 赋值，这时 a 的引用变成 {n: 2}，b 引用还是原来的
```

```js
    function Foo() {
        getName = function () { // window.getName
            console.log(1);
        };
        return this; // window
    }
    Foo.getName = function () {
        console.log(2);
    };
    Foo.prototype.getName = function () {
        console.log(3);
    };
    var getName = function () {
        console.log(4);
    };
    function getName() {
        console.log(5);
    }

    Foo.getName(); // ?
    getName(); // ?
    Foo().getName(); // ?
    getName(); // ?
    new Foo.getName(); // ?
    new Foo().getName(); // ?
    new new Foo().getName(); // ?

  // 函数是一等功能，高于一切
  // 2
  // 4
  // 1
  // 1
  // 2
  // 3
  // 3
```

## 引用

* <https://www.jianshu.com/p/485be922c4e7>
* <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence>